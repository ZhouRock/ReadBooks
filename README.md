# 第1章：引言

![](.gitbook/assets/bu-huo-%20%284%29.png)

**译者**：这是一篇非常经典的文章，讲了内存的各个方面，有你知道的，也有你不知道的，写作的时间有点早，有些技术不是最新的了，但即使是今天来看，基础框架都还是类似的，并不影响我们理解内存系统。硬件工程师为我们带来了更加复杂的内存处理及加速技术，比如说CPU缓存，直接内存访问DMA等，但如果离开了聪明的程序员它们就无法发挥出最大的价值，特别是如果你正在编写高性能的应用程序的话，了解现代系统中的内存知识尤为重要，因此推荐每一位有追求的程序员都读一读这篇文章。

翻译目标：准确流畅，而非逐字翻译，尽量让每一句原文都得到恰如其分的中文翻译，但是本人水平有限，错误还是在所难免的，如果你发现了错误或者更好的译法，欢迎反馈：**fengmuzi2003@gmail.com**

## **摘要**

随着CPU核变得越来越快和数量越来越多，内存访问会是现在以及将来一段时间内的限制因素，硬件设计师们虽然想出了一些复杂的内存处理和加速技术（比如CPU缓存），但是如果没有程序员的帮助，这些技术就没有办法以最优化的方式工作。不幸的是，绝大多数程序员既不知道计算机内存子系统以及CPU缓存的结构，也不了解它们带来的成本。本文介绍了现代商用硬件中所使用的内存子系统的结构，阐述了人们为何要开发出CPU缓存，它们是如何工作的，程序应该如何利用它们来达到性能的优化。

## **1. 引言**

早期计算机比现在更为简单，系统的各种组件，例如CPU，内存，大容量存储器和网络接口，被一起开发出来，因而有着相当均衡的表现。例如，内存和网络接口在提供数据的时候，速度并会比CPU快很多。

随着计算机基本结构的稳定，硬件开发人员开始致力于优化各个子系统，情况也开始有所改变。突然间，计算机的某些组件的性能大大落后，出现了瓶颈。对于大容量存储和内存子系统来说尤其如此，由于成本的原因，相对于其他组件，大容量存储和内存子系统的改进速度较为缓慢。

大容量存储的性能问题往往靠软件技术来改善：操作系统将最常用的（且最有可能被用到的）数据放在主存中，因为后者的访问速度要比前者快几个数量级。或者将缓存加入存储设备自身之中，这样就可以在不修改操作系统的前提下提升性能 _{ 脚注1：为了在使用缓存时确保数据的完整性，仍然要作出一些修改 }_ ，出于本文的目的（_主要是讨论内存_），针对大容量存储访问的软件优化细节，我们不做深入讨论。

与大容量存储不同，解决内存的瓶颈更为困难，几乎每种方案都需要对硬件作出修改。目前，针对内存进行的变更主要通过以下几种方式：

* RAM的硬件设计（速度与并发）
* 内存控制器的设计
* CPU缓存
* 设备的直接内存访问（DMA）

本文主要关心的是CPU缓存和内存控制器的设计。在讨论这些主题的过程中，我们还会顺带着探讨一下DMA。不过，我们首先会从当今商用硬件的设计谈起，因为这是我们理解目前在使用内存子系统时可能遇到的问题和限制的前提。我们还会比较详细地介绍一下RAM的分类，说明为什么会存在不同类型的内存。

本文不会包含所有内容，也不会是最终的内容（_因为一切都在变化_）。我们的讨论范围仅限于商用硬件，并且仅限于其中的一小部分。另外，本文中的许多话题，我们只会点到为止，达到本文的目的即可。对于这些话题，推荐大家自己阅读相关的文档，获得更详细的说明。

当涉及到操作系统特定的细节和解决方案的时候，内容针对的都是Linux，无论何时都不会包含其他操作系统的信息，作者对于讨论其他操作系统的影响兴趣不大。如果读者认为他/她不得不使用别的操作系统，那么应该找到操作系统的供应商，让他们提供类似本文的文档。

在正式开始之前作最后一点说明，本文会出现大量 “通常” 或者别的类似的限定词。这里讨论的技术在现实世界中存在很多不同的实现方式，本文只阐述使用得最广泛最主流的版本，针对某项技术很少能够做出绝对性的陈述，所以文中才出现了这些限定词。

## **文档结构**

本文档主要是为软件开发者（_程序员_）而写的，不会涉及太多硬件细节，所以面向硬件的读者也许不会觉得太有用，在我们讨论一些实际的细节之前，我们先要描述足够多的背景。

为此，本文的第2章将描述随机存储器（RAM），搞懂这个部分固然很好，但是该部分并不是你理解后续章节的关键必须知识，我们后面在需要的地方会添加适当的反向引用，所以心急的读者可以跳过第2章来阅读他们认为最有用的部分。

第3章会谈论不少关于CPU缓存的内容，我们会列出一些图表，这样你们就不至于觉得太枯燥。第3章对于你理解剩余的章节来说非常重要。

第4章将简短描述虚拟内存是怎样实现的，这也是理解全文其他部分的背景知识之一。

第5章会提到许多关于非一致内存访问 \(NUMA\) 系统的内容。

第6章是本文的中心部分，在这个部分里面，我们将把之前讲过的知识串联起来，为程序员提供在各种情况下的编程建议，如果你真的没有太多的耐心，那么你可以直接阅读第6章，并且我们建议你在必要的时候回到之前的章节来回顾一下必要的背景知识。

第7章将介绍一些能够帮助程序员更好地完成任务的工具，即便是在你自认为已经彻底理解了某项技术的情况下，实际上你距离真正理解生产环境下的程序问题还是相距甚远，这时候借助一些工具就很有必要。

最后，第8章我们给出了在不久的将来可以预期的技术前景，或者是那时候最好能拥有的技术。

## **反馈问题**

作者会不定期更新这份文档，既包括伴随技术进步而来的更新也包含错误修正。非常欢迎有志于反馈问题的读者发送电子邮件给作者。请在反馈中包括确切的版本信息，版本信息可以在文档的最后一页找到。

## **致谢**

我首先需要感谢Johnray Fuller和LWN（_Linux Weekly News_）的工作人员（特别是Jonathan Corbet，感谢你将作者的英语转化成为更为规范的形式，感谢Markus Armbruster，你对文中的问题和疏漏提供了大量有价值的建议）。

## **关于本文**

本文的题目是对David Goldberg的经典论文《What Every Computer Scientist Should Know About Floating-Point Arithmetic》（_每一个计算机科学家应该知道的浮点运算_）【参考文献12】 表示致敬。Goldberg的这篇论文虽然还没有广为流传，但是我想如果你想要成为一个严谨的程序员，阅读它都会是一个先决条件。

